/*******************************************************************************
 * BAREFOOT NETWORKS CONFIDENTIAL & PROPRIETARY
 *
 * Copyright (c) 2015-2016 Barefoot Networks, Inc.

 * All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of
 * Barefoot Networks, Inc. and its suppliers, if any. The intellectual and
 * technical concepts contained herein are proprietary to Barefoot Networks,
 * Inc.
 * and its suppliers and may be covered by U.S. and Foreign Patents, patents in
 * process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material is
 * strictly forbidden unless prior written permission is obtained from
 * Barefoot Networks, Inc.
 *
 * No warranty, explicit or implicit is provided, unless granted under a
 * written agreement with Barefoot Networks, Inc.
 *
 * $Id: $
 *
 ******************************************************************************/

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>

#include "switch_sai_rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <arpa/inet.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <sai.h>
#ifdef __cplusplus
}
#endif

#include <saifdb.h>
#include <saivlan.h>
#include <saivirtualrouter.h>
#include <sairouterinterface.h>
#include <sairoute.h>
#include <saiswitch.h>
#include <saimirror.h>
#include <saistatus.h>

#include "arpa/inet.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace ::switch_sai;

static pthread_mutex_t cookie_mutex;
static pthread_cond_t cookie_cv;
static void *cookie;

class switch_sai_rpcHandler : virtual public switch_sai_rpcIf {
 public:
  switch_sai_rpcHandler() {
    // Your initialization goes here
  }

  std::string sai_ipv4_to_thrift_string(const std::string s, unsigned int *m) {
    char v4[INET_ADDRSTRLEN];
    std::string dst_str;
    memset(v4, 0, sizeof(v4));
    dst_str = inet_ntop(AF_INET, (void *)m, v4, INET_ADDRSTRLEN);
    return dst_str;
  }

  std::string sai_ipv6_to_thrift_string(const std::string s, unsigned char *m) {
    char v6[INET6_ADDRSTRLEN];
    std::string dst_str;
    memset(v6, 0, sizeof(v6));
    dst_str = inet_ntop(AF_INET6, (void *)m, v6, INET6_ADDRSTRLEN);
    return dst_str;
  }

  std::string sai_mac_to_thrift_string(unsigned char *m) {
    char mac[19];
    std::string mac_str;
    sprintf(mac,
            "%02x:%02x:%02x:%02x:%02x:%02x",
            m[0],
            m[1],
            m[2],
            m[3],
            m[4],
            m[5]);
    mac_str = std::string(mac);
    return mac_str;
  }

  unsigned int sai_thrift_string_to_mac(const std::string s, unsigned char *m) {
    unsigned int i, j = 0;
    memset(m, 0, 6);
    for (i = 0; i < s.size(); i++) {
      char let = s.c_str()[i];
      if (let >= '0' && let <= '9') {
        m[j / 2] = (m[j / 2] << 4) + (let - '0');
        j++;
      } else if (let >= 'a' && let <= 'f') {
        m[j / 2] = (m[j / 2] << 4) + (let - 'a' + 10);
        j++;
      } else if (let >= 'A' && let <= 'F') {
        m[j / 2] = (m[j / 2] << 4) + (let - 'A' + 10);
        j++;
      }
    }
    return (j == 12);
  }

  void sai_thrift_string_to_v4_ip(const std::string s, unsigned int *m) {
    unsigned char r = 0;
    unsigned int i;
    *m = 0;
    for (i = 0; i < s.size(); i++) {
      char let = s.c_str()[i];
      if (let >= '0' && let <= '9') {
        r = (r * 10) + (let - '0');
      } else {
        *m = (*m << 8) | r;
        r = 0;
      }
    }
    *m = (*m << 8) | (r & 0xFF);
    *m = htonl(*m);
    return;
  }

  void sai_thrift_string_to_v6_ip(const std::string s, unsigned char *v6_ip) {
    const char *v6_str = s.c_str();
    inet_pton(AF_INET6, v6_str, v6_ip);
    return;
  }

  void sai_v4_ip_to_thrift_string(const std::string s, unsigned int *m) {
    return;
  }

  void sai_to_v6_ip_thrift_string(std::string s, unsigned char *v6_ip) {
    return;
  }

  void sai_thrift_parse_object_id_list(
      const std::vector<sai_thrift_object_id_t> &thrift_object_id_list,
      sai_object_id_t *object_id_list) {
    std::vector<sai_thrift_object_id_t>::const_iterator it =
        thrift_object_id_list.begin();
    for (uint32_t i = 0; i < thrift_object_id_list.size(); i++, it++) {
      object_id_list[i] = (sai_object_id_t)*it;
    }
  }

  void sai_thrift_parse_bridge_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_BRIDGE_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_BRIDGE_ATTR_MAX_LEARNED_ADDRESSES:
          attr_list[i].value.s32 = attribute.value.u32;
          break;
        case SAI_BRIDGE_ATTR_LEARN_DISABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        default:
          break;
      }
    }
    return;
  }

  void sai_thrift_parse_bridge_port_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_BRIDGE_PORT_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_BRIDGE_PORT_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_BRIDGE_PORT_ATTR_PORT_ID:
        case SAI_BRIDGE_PORT_ATTR_RIF_ID:
        case SAI_BRIDGE_PORT_ATTR_TUNNEL_ID:
        case SAI_BRIDGE_PORT_ATTR_BRIDGE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;

        case SAI_BRIDGE_PORT_ATTR_MAX_LEARNED_ADDRESSES:
          attr_list[i].value.s32 = attribute.value.u32;
          break;
        case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_LIMIT_VIOLATION_PACKET_ACTION:
        case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
    return;
  }

  void sai_thrift_parse_vlan_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_VLAN_MEMBER_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        default:
          break;
      }
    }
  }
  void sai_thrift_parse_vlan_member_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_VLAN_MEMBER_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_ip_address(
      const sai_thrift_ip_address_t &thrift_ip_address,
      sai_ip_address_t *ip_address) {
    ip_address->addr_family =
        (sai_ip_addr_family_t)thrift_ip_address.addr_family;
    if ((sai_ip_addr_family_t)thrift_ip_address.addr_family ==
        SAI_IP_ADDR_FAMILY_IPV4) {
      sai_thrift_string_to_v4_ip(thrift_ip_address.addr.ip4,
                                 &ip_address->addr.ip4);
    } else {
      sai_thrift_string_to_v6_ip(thrift_ip_address.addr.ip6,
                                 ip_address->addr.ip6);
    }
  }

  void sai_thrift_deparse_ip_address(sai_thrift_ip_address_t &thrift_ip_address,
                                     sai_ip_address_t *ip_address) {
    thrift_ip_address.addr_family =
        (sai_thrift_ip_addr_family_t)ip_address->addr_family;
    if ((sai_ip_addr_family_t)thrift_ip_address.addr_family ==
        SAI_IP_ADDR_FAMILY_IPV4) {
      sai_v4_ip_to_thrift_string(thrift_ip_address.addr.ip4,
                                 &ip_address->addr.ip4);
    } else {
      sai_to_v6_ip_thrift_string(thrift_ip_address.addr.ip6,
                                 ip_address->addr.ip6);
    }
  }

  void sai_thrift_parse_ip_prefix(
      const sai_thrift_ip_prefix_t &thrift_ip_prefix,
      sai_ip_prefix_t *ip_prefix) {
    ip_prefix->addr_family = (sai_ip_addr_family_t)thrift_ip_prefix.addr_family;
    if ((sai_ip_addr_family_t)thrift_ip_prefix.addr_family ==
        SAI_IP_ADDR_FAMILY_IPV4) {
      sai_thrift_string_to_v4_ip(thrift_ip_prefix.addr.ip4,
                                 &ip_prefix->addr.ip4);
      sai_thrift_string_to_v4_ip(thrift_ip_prefix.mask.ip4,
                                 &ip_prefix->mask.ip4);
    } else {
      sai_thrift_string_to_v6_ip(thrift_ip_prefix.addr.ip6,
                                 ip_prefix->addr.ip6);
      sai_thrift_string_to_v6_ip(thrift_ip_prefix.mask.ip6,
                                 ip_prefix->mask.ip6);
    }
  }

  void sai_thrift_parse_attribute_ids(
      const std::vector<int32_t> &thrift_attr_id_list,
      sai_attribute_t *attr_list) {
    std::vector<int32_t>::const_iterator it = thrift_attr_id_list.begin();
    for (uint32_t i = 0; i < thrift_attr_id_list.size(); i++, it++) {
      attr_list[i].id = (int32_t)*it;
    }
  }

  void sai_thrift_parse_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry,
      sai_fdb_entry_t *fdb_entry) {
    fdb_entry->vlan_id = (sai_vlan_id_t)thrift_fdb_entry.vlan_id;
    fdb_entry->bridge_id = (sai_object_id_t)thrift_fdb_entry.bridge_id;
    fdb_entry->bridge_type =
        (sai_fdb_entry_bridge_type_t)thrift_fdb_entry.bridge_type;
    sai_thrift_string_to_mac(thrift_fdb_entry.mac_address,
                             fdb_entry->mac_address);
  }

  void sai_thrift_parse_port_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_PORT_ATTR_ADMIN_STATE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_PORT_ATTR_PORT_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_PORT_ATTR_SPEED:
        case SAI_PORT_ATTR_FEC_MODE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_PORT_ATTR_HW_LANE_LIST: {
          attr_list[i].value.s32list.list = (int32_t *)malloc(
              sizeof(int32_t) * attribute.value.s32list.count);
          attr_list[i].value.s32list.count = attribute.value.s32list.count;
          std::vector<int32_t>::const_iterator it1 =
              attribute.value.s32list.s32list.begin();
          uint32_t lane_num = 0;
          for (int32_t j = 0; j < attribute.value.s32list.count; j++, it1++) {
            lane_num = (uint32_t)(*it1);
            attr_list[i].value.s32list.list[j] = lane_num;
          }
        } break;
        case SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP:
        case SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP:
        case SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP:
        case SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP:
        case SAI_PORT_ATTR_QOS_TC_TO_QUEUE_MAP:
        case SAI_PORT_ATTR_QOS_TC_TO_PRIORITY_GROUP_MAP:
        case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
        case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
        case SAI_PORT_ATTR_INGRESS_ACL:
        case SAI_PORT_ATTR_EGRESS_ACL:
        case SAI_PORT_ATTR_QOS_PFC_PRIORITY_TO_PRIORITY_GROUP_MAP:
        case SAI_PORT_ATTR_QOS_PFC_PRIORITY_TO_QUEUE_MAP:
        case SAI_PORT_ATTR_INGRESS_MIRROR_SESSION:
        case SAI_PORT_ATTR_EGRESS_MIRROR_SESSION:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_PORT_ATTR_BIND_MODE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_PORT_ATTR_GLOBAL_FLOW_CONTROL_MODE:
        case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL:
        case SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_INTERNAL_LOOPBACK_MODE:
        case SAI_PORT_ATTR_AUTO_NEG_MODE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_vlan_attribute(
      const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr) {
    attr->id = thrift_attr.id;
    switch (thrift_attr.id) {
      case SAI_VLAN_ATTR_STP_INSTANCE:
        attr->value.oid = thrift_attr.value.oid;
        break;
      case SAI_VLAN_ATTR_LEARN_DISABLE:
        attr->value.booldata = thrift_attr.value.booldata;
        break;
      default:
        attr->value.u32 = thrift_attr.value.u32;
        break;
    }
  }

  void sai_thrift_parse_route_entry(
      const sai_thrift_route_entry_t &thrift_route_entry,
      sai_route_entry_t *route_entry) {
    route_entry->vr_id = (sai_object_id_t)thrift_route_entry.vr_id;
    sai_thrift_parse_ip_prefix(thrift_route_entry.destination,
                               &route_entry->destination);
  }

  void sai_thrift_parse_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
      sai_neighbor_entry_t *neighbor_entry) {
    neighbor_entry->rif_id = (sai_object_id_t)thrift_neighbor_entry.rif_id;
    sai_thrift_parse_ip_address(thrift_neighbor_entry.ip_address,
                                &neighbor_entry->ip_address);
  }

  void sai_thrift_parse_fdb_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_FDB_ENTRY_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_FDB_ENTRY_ATTR_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_fdb_flush_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_FDB_FLUSH_ATTR_BRIDGE_PORT_ID:
          attr_list[i].value.oid = (sai_object_id_t)attribute.value.oid;
          break;
        case SAI_FDB_FLUSH_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_FDB_FLUSH_ATTR_ENTRY_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
      }
    }
  }

  void sai_thrift_parse_vr_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V4_STATE:
        case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V6_STATE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_VIRTUAL_ROUTER_ATTR_SRC_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
      }
    }
  }

  void sai_thrift_parse_route_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_router_interface_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID:
        case SAI_ROUTER_INTERFACE_ATTR_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
        case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE:
        case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE:
        case SAI_ROUTER_INTERFACE_ATTR_V4_MCAST_ENABLE:
        case SAI_ROUTER_INTERFACE_ATTR_V6_MCAST_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_MTU:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_deparse_router_interface_attributes(
      sai_thrift_attribute_list_t &out_attr_list,
      const std::vector<sai_thrift_attribute_t> &in_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        in_attr_list.begin();
    sai_thrift_attribute_t attribute;

    for (uint32_t i = 0; i < in_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      switch (attr_list[i].id) {
        case SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID:
        case SAI_ROUTER_INTERFACE_ATTR_PORT_ID:
          attribute.value.oid = attr_list[i].value.oid;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_TYPE:
          attribute.value.s32 = attr_list[i].value.s32;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_VLAN_ID:
          attribute.value.u16 = attr_list[i].value.u16;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS:
          //                  sai_thrift_string_to_mac(attribute.value.mac,
          //                  attr_list[i].value.mac);
          break;
        case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE:
        case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE:
        case SAI_ROUTER_INTERFACE_ATTR_V4_MCAST_ENABLE:
        case SAI_ROUTER_INTERFACE_ATTR_V6_MCAST_ENABLE:
          attribute.value.booldata = attr_list[i].value.booldata;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_MTU:
          attribute.value.u32 = attr_list[i].value.u32;
          break;
        default:
          break;
      }
      out_attr_list.attr_list.push_back(attribute);
    }
  }

  void sai_thrift_parse_next_hop_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NEXT_HOP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_NEXT_HOP_ATTR_IP:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  void sai_thrift_deparse_next_hop_attributes(
      std::vector<sai_thrift_attribute_t> &out_attr_list,
      const std::vector<sai_thrift_attribute_t> &in_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        in_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < in_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      switch (attr_list[i].id) {
        case SAI_NEXT_HOP_ATTR_TYPE:
          attribute.value.s32 = attr_list[i].value.s32;
          break;
        case SAI_NEXT_HOP_ATTR_IP:
          sai_thrift_deparse_ip_address(attribute.value.ipaddr,
                                        &attr_list[i].value.ipaddr);
          break;
        case SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID:
          attribute.value.oid = attr_list[i].value.oid;
          break;
      }
      out_attr_list.push_back(attribute);
    }
  }

  void sai_thrift_parse_next_hop_group_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_object_id_t **nhop_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NEXT_HOP_GROUP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_MEMBER_LIST:
          *nhop_list = (sai_object_id_t *)malloc(sizeof(sai_object_id_t) *
                                                 attribute.value.objlist.count);
          std::vector<sai_thrift_object_id_t>::const_iterator it2 =
              attribute.value.objlist.object_id_list.begin();
          for (uint32_t j = 0;
               j < attribute.value.objlist.object_id_list.size();
               j++, *it2++) {
            (*nhop_list)[j] = (sai_object_id_t)*it2;
          }
          attr_list[i].value.objlist.count = attribute.value.objlist.count;
          attr_list[i].value.objlist.list = *nhop_list;
          break;
      }
    }
  }

  void sai_thrift_parse_next_hop_group_member_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_WEIGHT:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
      }
    }
  }

  void sai_thrift_parse_lag_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_object_id_t **port_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_LAG_ATTR_PORT_LIST:
          *port_list = (sai_object_id_t *)malloc(sizeof(sai_object_id_t) *
                                                 attribute.value.objlist.count);
          std::vector<sai_thrift_object_id_t>::const_iterator it2 =
              attribute.value.objlist.object_id_list.begin();
          for (uint32_t j = 0;
               j < attribute.value.objlist.object_id_list.size();
               j++, it2++) {
            (*port_list)[j] = (sai_object_id_t)*it2;
          }
          attr_list[i].value.objlist.count = attribute.value.objlist.count;
          attr_list[i].value.objlist.list = *port_list;
          break;
      }
    }
  }

  void sai_thrift_parse_lag_member_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_LAG_MEMBER_ATTR_LAG_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_LAG_MEMBER_ATTR_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE:
          break;
        case SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE:
          break;
      }
    }
  }

  void sai_thrift_parse_stp_port_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_STP_PORT_ATTR_STP:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_STP_PORT_ATTR_BRIDGE_PORT:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_STP_PORT_ATTR_STATE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
      }
    }
  }

  void sai_thrift_parse_stp_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_vlan_id_t **vlan_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_STP_ATTR_VLAN_LIST:
          *vlan_list = (sai_vlan_id_t *)malloc(
              sizeof(sai_vlan_id_t) * attribute.value.vlanlist.vlan_count);
          std::vector<sai_thrift_vlan_id_t>::const_iterator it2 =
              attribute.value.vlanlist.vlan_list.begin();
          for (uint32_t j = 0; j < attribute.value.vlanlist.vlan_list.size();
               j++, *it2++) {
            *vlan_list[j] = (sai_vlan_id_t)*it2;
          }
          attr_list[i].value.vlanlist.count =
              attribute.value.vlanlist.vlan_count;
          attr_list[i].value.vlanlist.list = *vlan_list;
          break;
      }
    }
  }

  void sai_thrift_parse_neighbor_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_HOSTIF_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_HOSTIF_ATTR_NAME:
          memcpy(attr_list[i].value.chardata,
                 attribute.value.chardata.c_str(),
                 HOSTIF_NAME_SIZE);
          break;
        case SAI_HOSTIF_ATTR_OBJ_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_talbe_entry_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_CHANNEL_TYPE:
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_TYPE:
        case SAI_HOSTIF_ATTR_VLAN_TAG:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_OBJ_ID:
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_HOST_IF:
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_TRAP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_hostif_trap_group_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_HOSTIF_TRAP_GROUP_ATTR_QUEUE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_HOSTIF_TRAP_GROUP_ATTR_POLICER:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_trap_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      sai_thrift_parse_hostif_trap_attribute(attribute, &attr_list[i]);
    }
  }

  void sai_thrift_parse_hostif_trap_attribute(
      const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr) {
    attr->id = thrift_attr.id;
    switch (thrift_attr.id) {
      case SAI_HOSTIF_TRAP_ATTR_TRAP_TYPE:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
        attr->value.oid = thrift_attr.value.oid;
        break;
      default:
        break;
    }
  }

  sai_thrift_object_id_t sai_thrift_create_port(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api = NULL;
    sai_object_id_t port_id = 0;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_port_attributes(thrift_attr_list, attr_list);
    status = port_api->create_port(&port_id, 0, attr_count, attr_list);
    return port_id;
  }

  sai_thrift_status_t sai_thrift_remove_port(
      const sai_thrift_object_id_t port_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api = NULL;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = port_api->remove_port(port_id);
    return status;
  }

  int32_t sai_thrift_set_port_attribute(
      const sai_thrift_object_id_t port_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_port_attributes(thrift_attr_list, &attr);
    status = port_api->set_port_attribute((sai_object_id_t)port_id, &attr);
    return status;
  }

  void sai_thrift_convert_to_port_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_value_list) {
    sai_attribute_t attr;
    sai_thrift_attribute_t thrift_port_attribute;

    thrift_attr_value_list.attr_count = attr_count;
    for (int i = 0; i < attr_count; i++) {
      attr = attr_list[i];
      thrift_port_attribute.id = attr.id;
      switch (attr.id) {
        case SAI_PORT_ATTR_GLOBAL_FLOW_CONTROL_MODE:
        case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL:
        case SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES:
        case SAI_PORT_ATTR_INTERNAL_LOOPBACK_MODE:
        case SAI_PORT_ATTR_SPEED:
        case SAI_PORT_ATTR_FEC_MODE:
          thrift_port_attribute.value.u32 = attr.value.u32;
          break;

        case SAI_PORT_ATTR_AUTO_NEG_MODE:
          thrift_port_attribute.value.booldata = attr.value.booldata;
          break;

        case SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP:
        case SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP:
        case SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP:
        case SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP:
        case SAI_PORT_ATTR_QOS_TC_TO_QUEUE_MAP:
        case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
        case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
        case SAI_PORT_ATTR_INGRESS_MIRROR_SESSION:
        case SAI_PORT_ATTR_EGRESS_MIRROR_SESSION:
          thrift_port_attribute.value.oid = attr.value.oid;
          break;
        default:
          thrift_port_attribute.value.u32 = attr.value.u32;
          break;
      }
      thrift_attr_value_list.attr_list.push_back(thrift_port_attribute);
    }
  }

  void sai_thrift_get_port_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t port_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    sai_attribute_t port_attr;

    uint32_t attr_count = thrift_attr_ids.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_ids.size());

    memset(
        attr_list, 0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = port_api->get_port_attribute(port_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }

    sai_thrift_convert_to_port_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
    return;
  }

  void sai_thrift_get_port_handles_attribute(
      sai_thrift_attribute_t &thrift_attr,
      sai_thrift_object_id_t port_id,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    uint32_t num_ppgs = 0;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    sai_attribute_t port_attr;
    switch (attr.id) {
      case SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST: {
        port_attr.id = SAI_PORT_ATTR_NUMBER_OF_INGRESS_PRIORITY_GROUPS;
        status = port_api->get_port_attribute(port_id, 1, &port_attr);
        num_ppgs = port_attr.value.u32;

        port_attr.value.objlist.list =
            (sai_object_id_t *)malloc(num_ppgs * sizeof(sai_object_id_t));
        port_attr.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
        status = port_api->get_port_attribute(port_id, 1, &port_attr);

        thrift_attr.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
        thrift_attr.value.objlist.count = num_ppgs;
        std::vector<sai_thrift_object_id_t> &ppg_list =
            thrift_attr.value.objlist.object_id_list;

        for (int index = 0; index < num_ppgs; index++) {
          ppg_list.push_back(
              (sai_thrift_object_id_t)port_attr.value.objlist.list[index]);
        }

        free(port_attr.value.objlist.list);
      } break;
      case SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST: {
        port_attr.id = SAI_PORT_ATTR_QOS_NUMBER_OF_SCHEDULER_GROUPS;
        status = port_api->get_port_attribute(port_id, 1, &port_attr);
        int num_sch_groups = port_attr.value.u32;

        port_attr.id = SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST;
        port_attr.value.objlist.list =
            (sai_object_id_t *)malloc(num_sch_groups * sizeof(sai_object_id_t));
        memset(port_attr.value.objlist.list,
               0,
               num_sch_groups * sizeof(sai_object_id_t));
        status = port_api->get_port_attribute(port_id, 1, &port_attr);

        thrift_attr.value.objlist.count = num_sch_groups;
        std::vector<sai_thrift_object_id_t> &group_list =
            thrift_attr.value.objlist.object_id_list;

        for (int index = 0; index < num_sch_groups; index++) {
          group_list.push_back(port_attr.value.objlist.list[index]);
        }
        free(port_attr.value.objlist.list);
      } break;

      case SAI_PORT_ATTR_QOS_QUEUE_LIST: {
        port_attr.id = SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES;
        status = port_api->get_port_attribute(port_id, 1, &port_attr);
        int num_queues = port_attr.value.u32;

        port_attr.id = SAI_PORT_ATTR_QOS_QUEUE_LIST;
        port_attr.value.objlist.list =
            (sai_object_id_t *)malloc(num_queues * sizeof(sai_object_id_t));
        memset(port_attr.value.objlist.list,
               0,
               num_queues * sizeof(sai_object_id_t));
        status = port_api->get_port_attribute(port_id, 1, &port_attr);

        thrift_attr.value.objlist.count = num_queues;
        std::vector<sai_thrift_object_id_t> &group_list =
            thrift_attr.value.objlist.object_id_list;

        for (int index = 0; index < num_queues; index++) {
          group_list.push_back(port_attr.value.objlist.list[index]);
        }
        free(port_attr.value.objlist.list);
      } break;
    }

    return;
  }

  void sai_thrift_get_port_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t port_id,
      const std::vector<sai_thrift_port_stat_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    sai_port_stat_t *counter_ids = (sai_port_stat_t *)malloc(
        sizeof(sai_port_stat_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_port_stat_t)*it;
    }

    status = port_api->get_port_stats(
        port_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }

    free(counter_ids);
    free(counters);
    return;
  }

  int32_t sai_thrift_clear_port_stats(
      const sai_thrift_object_id_t port_id,
      const std::vector<sai_thrift_port_stat_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_port_stat_t *counter_ids = (sai_port_stat_t *)malloc(
        sizeof(sai_port_stat_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();

    status = port_api->clear_port_stats(
            port_id, number_of_counters, counter_ids);

    free(counter_ids);
    return status;
  }

  int32_t sai_thrift_clear_port_all_stats(
      const sai_thrift_object_id_t port_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    status = port_api->clear_port_all_stats(port_id);
    return status;
  }

  int32_t sai_thrift_create_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    sai_fdb_entry_t fdb_entry;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_fdb_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = fdb_api->create_fdb_entry(&fdb_entry, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  int32_t sai_thrift_delete_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    sai_fdb_entry_t fdb_entry;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    status = fdb_api->remove_fdb_entry(&fdb_entry);
    return status;
  }

  int32_t sai_thrift_flush_fdb_entries(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_fdb_flush_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = fdb_api->flush_fdb_entries(0, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  void sai_thrift_get_fdb_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_fdb_entry_t &thrift_fdb_entry,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    sai_fdb_entry_t fdb_entry;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t));

    sai_thrift_attribute_t thrift_fdb_attribute;
    memset(attr_list, 0, sizeof(sai_attribute_t));
    attr_list[0].id = thrift_attr.id;

    status = fdb_api->get_fdb_entry_attribute(&fdb_entry, 1, attr_list);
    if (status == SAI_STATUS_SUCCESS) {
      thrift_attr_values.attr_count = 1;
      thrift_fdb_attribute.id = thrift_attr.id;
      if (thrift_fdb_attribute.id == SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID) {
        thrift_fdb_attribute.value.oid = attr_list[0].value.oid;
      } else {
        thrift_fdb_attribute.value.u32 = attr_list[0].value.u32;
      }
    }
    thrift_attr_values.attr_list.push_back(thrift_fdb_attribute);
    free(attr_list);
  }

  int32_t sai_thrift_set_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    sai_fdb_entry_t fdb_entry;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    sai_attribute_t sai_attr;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    sai_attr.id = thrift_attr.id;
    if (sai_attr.id == SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID) {
      sai_attr.value.oid = thrift_attr.value.oid;
    } else {
      sai_attr.value.u32 = thrift_attr.value.u32;
    }
    status = fdb_api->set_fdb_entry_attribute(&fdb_entry, &sai_attr);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_object_id_t bridge_id;
    sai_thrift_parse_bridge_attributes(thrift_attr_list, attr_list);
    status = bridge_api->create_bridge(&bridge_id, 0, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
    }
    return bridge_id;
  }

  int32_t sai_thrift_delete_bridge(const sai_thrift_object_id_t bridge_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    return bridge_api->remove_bridge(bridge_id);
  }

  sai_thrift_object_id_t sai_thrift_create_bridge_port(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_object_id_t bridge_port_id;
    sai_thrift_parse_bridge_port_attributes(thrift_attr_list, attr_list);
    status = bridge_api->create_bridge_port(
        &bridge_port_id, 0, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
    }
    return bridge_port_id;
  }

  int32_t sai_thrift_delete_bridge_port(
      const sai_thrift_object_id_t bridge_port_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    return bridge_api->remove_bridge_port(bridge_port_id);
  }

  sai_thrift_object_id_t sai_thrift_create_vlan(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_object_id_t vlan_id;
    sai_thrift_parse_vlan_attributes(thrift_attr_list, attr_list);
    status = vlan_api->create_vlan(&vlan_id, 0, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    return vlan_id;
  }

  int32_t sai_thrift_set_vlan_attribute(
      const sai_thrift_vlan_id_t vlan_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api = NULL;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr;
    sai_thrift_parse_vlan_attribute(thrift_attr, &attr);
    status = vlan_api->set_vlan_attribute((sai_object_id_t)vlan_id, &attr);
    return status;
  }

  void sai_thrift_get_vlan_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t vlan_id,
      const int32_t member_count,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api = NULL;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);

    sai_attribute_t vlan_attr;
    sai_thrift_parse_vlan_attribute(thrift_attr, &vlan_attr);
    if (vlan_attr.id == SAI_VLAN_ATTR_MEMBER_LIST) {
      assert(member_count != 0);
      vlan_attr.value.objlist.list =
          (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * member_count);
    }
    status =
        vlan_api->get_vlan_attribute((sai_object_id_t)vlan_id, 1, &vlan_attr);

    thrift_attr_list.attr_count = 1;
    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;

    sai_thrift_attribute_t thrift_vlan_attribute;
    sai_object_list_t *port_list_object;

    thrift_vlan_attribute.id = vlan_attr.id;
    if (vlan_attr.id == SAI_VLAN_ATTR_MEMBER_LIST) {
      thrift_vlan_attribute.value.objlist.count = member_count;
      std::vector<sai_thrift_object_id_t> &port_list =
          thrift_vlan_attribute.value.objlist.object_id_list;
      port_list_object = &vlan_attr.value.objlist;

      for (int index = 0; index < member_count; index++) {
        port_list.push_back(
            (sai_thrift_object_id_t)port_list_object->list[index]);
      }
    } else if (vlan_attr.id == SAI_VLAN_ATTR_LEARN_DISABLE) {
      thrift_vlan_attribute.value.booldata = vlan_attr.value.booldata;
    } else {
      thrift_vlan_attribute.value.u32 = vlan_attr.value.u32;
    }

    if (vlan_attr.id == SAI_VLAN_ATTR_MEMBER_LIST) {
      free(vlan_attr.value.objlist.list);
    }
    attr_list.push_back(thrift_vlan_attribute);
    return;
  }

  int32_t sai_thrift_delete_vlan(const sai_thrift_vlan_id_t vlan_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = vlan_api->remove_vlan((sai_vlan_id_t)vlan_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    sai_object_id_t vlan_member_id = 0;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_vlan_member_attributes(thrift_attr_list, attr_list);
    status =
        vlan_api->create_vlan_member(&vlan_member_id, 0, attr_count, attr_list);
    return vlan_member_id;
  }

  void sai_thrift_get_vlan_member_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t vlan_member_handle,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api = NULL;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t));
    memset(attr_list, 0, sizeof(sai_attribute_t));
    attr_list[0].id = thrift_attr.id;
    status = vlan_api->get_vlan_member_attribute(
        (sai_object_id_t)vlan_member_handle, 1, attr_list);
    sai_thrift_attribute_t thrift_vlan_member_attribute;
    if (status == SAI_STATUS_SUCCESS) {
      thrift_attr_values.attr_count = 1;
      thrift_vlan_member_attribute.id = thrift_attr.id;
      if (thrift_attr.id == SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID) {
        thrift_vlan_member_attribute.value.oid = attr_list[0].value.oid;
      } else {
        thrift_vlan_member_attribute.value.u32 = attr_list[0].value.u32;
      }
    }
    thrift_attr_values.attr_list.push_back(thrift_vlan_member_attribute);
    free(attr_list);
  }

  sai_thrift_status_t sai_thrift_set_vlan_member_attribute(
      const sai_thrift_object_id_t vlan_member_handle,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api = NULL;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);

    sai_attribute_t vlan_member_attr;
    memset(&vlan_member_attr, 0, sizeof(vlan_member_attr));
    vlan_member_attr.id = thrift_attr.id;
    vlan_member_attr.value.u32 = thrift_attr.value.u32;

    status = vlan_api->set_vlan_member_attribute(vlan_member_handle,
                                                 &vlan_member_attr);

    return status;
  }

  sai_thrift_status_t sai_thrift_remove_vlan_member(
      const sai_thrift_object_id_t vlan_member_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = vlan_api->remove_vlan_member(vlan_member_id);
    return status;
  }

  void sai_thrift_get_vlan_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_vlan_id_t vlan_id,
      const std::vector<sai_thrift_vlan_stat_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    sai_vlan_stat_t *counter_ids = (sai_vlan_stat_t *)malloc(
        sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_vlan_stat_t)*it;
    }

    status = vlan_api->get_vlan_stats(
        (sai_vlan_id_t)vlan_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_virtual_router(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *vr_api;
    sai_object_id_t vr_id = 0;
    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&vr_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_vr_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    vr_api->create_virtual_router(&vr_id, 0, attr_count, attr_list);
    return vr_id;
  }

  sai_thrift_status_t sai_thrift_remove_virtual_router(
      const sai_thrift_object_id_t vr_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *vr_api;
    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&vr_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = vr_api->remove_virtual_router((sai_object_id_t)vr_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_create_route(
      const sai_thrift_route_entry_t &thrift_route_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_api_t *route_api;
    sai_route_entry_t route_entry;
    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_route_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = route_api->create_route_entry(&route_entry, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_route(
      const sai_thrift_route_entry_t &thrift_route_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_api_t *route_api;
    sai_route_entry_t route_entry;
    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    status = route_api->remove_route_entry(&route_entry);
    return status;
  }

  void sai_thrift_get_route_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_route_entry_t &thrift_route_entry,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_api_t *route_api;
    sai_route_entry_t route_entry;
    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t));

    sai_thrift_attribute_t thrift_route_attribute;
    memset(attr_list, 0, sizeof(sai_attribute_t));
    attr_list[0].id = thrift_attr.id;

    status = route_api->get_route_entry_attribute(&route_entry, 1, attr_list);
    if (status == SAI_STATUS_SUCCESS) {
      thrift_attr_values.attr_count = 1;
      thrift_route_attribute.id = thrift_attr.id;
      if (thrift_attr.id == SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID) {
        thrift_route_attribute.value.oid = attr_list[0].value.oid;
      } else {
        thrift_route_attribute.value.u32 = attr_list[0].value.u32;
      }
    }
    thrift_attr_values.attr_list.push_back(thrift_route_attribute);
    free(attr_list);
  }

  int32_t sai_thrift_set_route_attribute(
      const sai_thrift_route_entry_t &thrift_route_entry,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_api_t *route_api;
    sai_route_entry_t route_entry;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);

    sai_attribute_t *route_attr;
    route_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t));
    memset(route_attr, 0, sizeof(sai_attribute_t));

    route_attr->id = thrift_attr.id;
    if (thrift_attr.id == SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID) {
      route_attr->value.oid = thrift_attr.value.oid;
    } else {
      route_attr->value.u32 = thrift_attr.value.u32;
    }

    status = route_api->set_route_entry_attribute(&route_entry, route_attr);
    free(route_attr);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_router_interface(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    sai_object_id_t rif_id = 0;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_router_interface_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status =
        rif_api->create_router_interface(&rif_id, 0, attr_count, attr_list);
    return rif_id;
  }

  sai_thrift_status_t sai_thrift_remove_router_interface(
      const sai_thrift_object_id_t rif_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = rif_api->remove_router_interface((sai_object_id_t)rif_id);
    return status;
  }

  int32_t sai_thrift_set_router_interface_attribute(
      const sai_thrift_object_id_t rif_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);

    sai_attribute_t sai_attr;
    sai_thrift_parse_router_interface_attributes(thrift_attr_list, &sai_attr);
    status = rif_api->set_router_interface_attribute(rif_id, &sai_attr);
    return status;
  }

  void sai_thrift_get_router_interface_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t rif_id,
      const int32_t attr_count,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    sai_attribute_t sai_attr;
    std::vector<sai_thrift_attribute_t> rif_thrift_attr_list;
    rif_thrift_attr_list.push_back(thrift_attr);

    sai_thrift_parse_router_interface_attributes(rif_thrift_attr_list,
                                                 &sai_attr);
    status = rif_api->get_router_interface_attribute(rif_id, 1, &sai_attr);

    sai_thrift_deparse_router_interface_attributes(
        thrift_attr_list, rif_thrift_attr_list, &sai_attr);
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *nhop_api;
    sai_object_id_t nhop_id = 0;
    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&nhop_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_next_hop_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = nhop_api->create_next_hop(&nhop_id, 0, attr_count, attr_list);
    return nhop_id;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop(
      const sai_thrift_object_id_t next_hop_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *nhop_api;
    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&nhop_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = nhop_api->remove_next_hop((sai_object_id_t)next_hop_id);
    return status;
  }

  void sai_thrift_get_next_hop_attribute(
      sai_thrift_get_response_t &_return,
      const sai_thrift_object_id_t next_hop_id,
      const int32_t attr_count,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *nhop_api;
    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&nhop_api);
    if (status != SAI_STATUS_SUCCESS) {
      _return.status = status;
      return;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_next_hop_attributes(thrift_attr_list, attr_list);

    status =
        nhop_api->get_next_hop_attribute(next_hop_id, attr_count, attr_list);
    _return.status = status;

    sai_thrift_deparse_next_hop_attributes(
        _return.attributes, thrift_attr_list, attr_list);
  }

  sai_thrift_status_t sai_thrift_set_next_hop_attribute(
      const sai_thrift_object_id_t next_hop_id,
      const std::vector<sai_thrift_attribute_t> &single_attribute) {
    // ensure singleton list
    assert(single_attribute.size() == 1);

    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *nhop_api;
    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&nhop_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * single_attribute.size());
    sai_thrift_parse_next_hop_attributes(single_attribute, attr_list);

    status = nhop_api->set_next_hop_attribute(next_hop_id, attr_list);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *nhop_group_api;
    sai_object_id_t nhop_group_id = 0;
    sai_object_id_t *nhop_list = NULL;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&nhop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_next_hop_group_attributes(
        thrift_attr_list, attr_list, &nhop_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = nhop_group_api->create_next_hop_group(
        &nhop_group_id, 0, attr_count, attr_list);
    if (nhop_list) free(nhop_list);
    free(attr_list);
    return nhop_group_id;
  }

  void sai_thrift_get_next_hop_group_attribute(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t nhop_group_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *nhop_group_api;
    uint32_t nhop_count = 0;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&nhop_group_api);

    sai_attribute_t *attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t));

    attr->id = SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT;
    nhop_group_api->get_next_hop_group_attribute(nhop_group_id, 1, attr);
    nhop_count = attr->value.u32;

    if (thrift_attr.id == SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_MEMBER_LIST) {
      attr->id = SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_MEMBER_LIST;
      attr->value.objlist.list =
          (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * nhop_count);
      nhop_group_api->get_next_hop_group_attribute(nhop_group_id, 1, attr);

      ret_thrift_attr.id = SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_MEMBER_LIST;
      ret_thrift_attr.value.objlist.count = nhop_count;

      for (int i = 0; i < nhop_count; i++) {
        ret_thrift_attr.value.objlist.object_id_list.push_back(
            (sai_thrift_object_id_t)attr->value.objlist.list[i]);
      }
      free(attr->value.objlist.list);
    } else if (thrift_attr.id == SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT) {
      ret_thrift_attr.id = SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT;
      ret_thrift_attr.value.u32 = nhop_count;
    }
    free(attr);
    return;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop_group(
      const sai_thrift_object_id_t next_hop_group_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *nhop_group_api = NULL;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&nhop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = nhop_group_api->remove_next_hop_group(next_hop_group_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *nhop_group_api = NULL;
    sai_object_id_t nhop_group_member_id = 0;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&nhop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_next_hop_group_member_attributes(thrift_attr_list,
                                                      attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = nhop_group_api->create_next_hop_group_member(
        &nhop_group_member_id, 0, attr_count, attr_list);
    free(attr_list);
    return nhop_group_member_id;
  }

  void sai_thrift_get_next_hop_group_member_attribute(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t nhop_group_member_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_next_hop_group_api_t *nhop_group_api = NULL;
    sai_status_t status;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&nhop_group_api);

    sai_attribute_t sai_attr;
    sai_attr.id = thrift_attr.id;
    nhop_group_api->get_next_hop_group_member_attribute(
        nhop_group_member_id, 1, &sai_attr);

    ret_thrift_attr.id = sai_attr.id;
    ret_thrift_attr.value.oid = sai_attr.value.oid;
    return;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop_group_member(
      const sai_thrift_object_id_t next_hop_group_member_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *nhop_group_api = NULL;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&nhop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status =
        nhop_group_api->remove_next_hop_group_member(next_hop_group_member_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_lag(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    sai_object_id_t lag_id = 0;
    sai_attribute_t *attr_list = NULL;
    uint32_t attr_count = 0;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = lag_api->create_lag(&lag_id, 0, attr_count, attr_list);
    return lag_id;
  }

  void sai_thrift_get_lag_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t lag_id,
      const int32_t member_count,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    sai_attribute_t lag_attribute;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);

    uint32_t attr_count = 1;

    lag_attribute.id = SAI_LAG_ATTR_PORT_LIST;
    lag_attribute.value.objlist.list =
        (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * member_count);

    assert(member_count != 0);
    status = lag_api->get_lag_attribute(lag_id, 1, &lag_attribute);

    if (status != SAI_STATUS_SUCCESS) {
      free(lag_attribute.value.objlist.list);
      return;
    }
    thrift_attr_list.attr_count = 1;
    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;

    sai_thrift_attribute_t thrift_lag_attribute;
    sai_object_list_t *port_list_object;

    thrift_lag_attribute.id = SAI_LAG_ATTR_PORT_LIST;
    thrift_lag_attribute.value.objlist.count = member_count;
    std::vector<sai_thrift_object_id_t> &port_list =
        thrift_lag_attribute.value.objlist.object_id_list;
    port_list_object = &lag_attribute.value.objlist;

    for (int index = 0; index < member_count; index++) {
      port_list.push_back(
          (sai_thrift_object_id_t)port_list_object->list[index]);
    }
    attr_list.push_back(thrift_lag_attribute);
    free(lag_attribute.value.objlist.list);
    return;
  }

  void sai_thrift_convert_to_lag_member_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_value_list) {
    sai_attribute_t attr;
    sai_thrift_attribute_t thrift_lag_member_attribute;

    thrift_attr_value_list.attr_count = attr_count;
    for (int i = 0; i < attr_count; i++) {
      attr = attr_list[i];
      switch (attr.id) {
        case SAI_LAG_MEMBER_ATTR_LAG_ID:
        case SAI_LAG_MEMBER_ATTR_PORT_ID:

          thrift_lag_member_attribute.id = attr.id;
          thrift_lag_member_attribute.value.oid = attr.value.oid;
          break;
      }
      thrift_attr_value_list.attr_list.push_back(thrift_lag_member_attribute);
    }
  }
  void sai_thrift_get_lag_member_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t lag_member_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    sai_attribute_t port_attr;

    uint32_t attr_count = thrift_attr_ids.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_ids.size());

    memset(
        attr_list, 0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status =
        lag_api->get_lag_member_attribute(lag_member_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }
    sai_thrift_convert_to_lag_member_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
    free(attr_list);
  }

  sai_thrift_status_t sai_thrift_remove_lag(
      const sai_thrift_object_id_t lag_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = lag_api->remove_lag((sai_object_id_t)lag_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_lag_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    sai_object_id_t lag_member_id;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_lag_member_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status =
        lag_api->create_lag_member(&lag_member_id, 0, attr_count, attr_list);
    return lag_member_id;
  }

  sai_thrift_status_t sai_thrift_remove_lag_member(
      const sai_thrift_object_id_t lag_member_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = lag_api->remove_lag_member(lag_member_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_stp(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    sai_object_id_t stp_id;
    sai_attribute_t *attr_list = NULL;
    uint32_t attr_count = 0;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status =
        (sai_object_id_t)stp_api->create_stp(&stp_id, 0, attr_count, attr_list);
    return stp_id;
  }

  void sai_thrift_get_stp_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t stp_id,
      const sai_thrift_attribute_t &thrift_attr,
      const int32_t count) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    sai_attribute_t sai_stp_attr;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    assert(count != 0);
    sai_stp_attr.id = thrift_attr.id;
    sai_stp_attr.value.objlist.list =
        (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * count);
    status = stp_api->get_stp_attribute(stp_id, 1, &sai_stp_attr);
    if (status != SAI_STATUS_SUCCESS) {
      free(sai_stp_attr.value.objlist.list);
      return;
    }

    sai_thrift_attribute_t thrift_stp_attribute;
    sai_object_list_t *sai_obj_list;
    thrift_stp_attribute.id = sai_stp_attr.id;
    thrift_stp_attribute.value.objlist.count = count;

    std::vector<sai_thrift_object_id_t> &thrift_obj_list =
        thrift_stp_attribute.value.objlist.object_id_list;

    sai_obj_list = &sai_stp_attr.value.objlist;
    for (int index = 0; index < count; index++) {
      thrift_obj_list.push_back(
          (sai_thrift_object_id_t)sai_obj_list->list[index]);
    }
    thrift_attr_list.attr_count = 1;
    thrift_attr_list.attr_list.push_back(thrift_stp_attribute);
    free(sai_stp_attr.value.objlist.list);
    return;
  }

  sai_thrift_status_t sai_thrift_remove_stp(
      const sai_thrift_object_id_t stp_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = (sai_thrift_status_t)stp_api->remove_stp(stp_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_stp_port(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api = NULL;
    sai_object_id_t stp_port_id = 0;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_stp_port_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = (sai_object_id_t)stp_api->create_stp_port(
        &stp_port_id, 0, attr_count, attr_list);
    free(attr_list);
    return stp_port_id;
  }

  sai_thrift_status_t sai_thrift_remove_stp_port(
      const sai_thrift_object_id_t stp_port_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = (sai_thrift_status_t)stp_api->remove_stp_port(stp_port_id);
    return status;
  }

  void sai_thrift_get_stp_port_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t stp_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    sai_attribute_t sai_attr;
    sai_thrift_attribute_t thrift_fdb_attribute;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));

    sai_thrift_attribute_t thrift_stp_port_attr;
    memset(&thrift_stp_port_attr, 0, sizeof(sai_thrift_attribute_t));
    sai_attr.id = thrift_attr.id;
    status =
        stp_api->get_stp_port_attribute((sai_object_id_t)stp_id, 1, &sai_attr);
    if (status == SAI_STATUS_SUCCESS) {
      thrift_attr_list.attr_count = 1;
      thrift_stp_port_attr.id = sai_attr.id;
      thrift_stp_port_attr.value.oid = sai_attr.value.oid;
    }
    thrift_attr_list.attr_list.push_back(thrift_stp_port_attr);
  }

  sai_thrift_status_t sai_thrift_create_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;
    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    sai_neighbor_entry_t neighbor_entry;
    memset(&neighbor_entry, 0, sizeof(neighbor_entry));
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_neighbor_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = neighbor_api->create_neighbor_entry(
        &neighbor_entry, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;
    sai_neighbor_entry_t neighbor_entry;
    memset(&neighbor_entry, 0, sizeof(neighbor_entry));
    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    status = neighbor_api->remove_neighbor_entry(&neighbor_entry);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;
    sai_neighbor_entry_t neighbor_entry;
    memset(&neighbor_entry, 0, sizeof(neighbor_entry));
    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    sai_attribute_t sai_attr;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    sai_attr.id = thrift_attr.id;
    if (sai_attr.id == SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS) {
      sai_thrift_string_to_mac(thrift_attr.value.mac, sai_attr.value.mac);
    }
    status =
        neighbor_api->set_neighbor_entry_attribute(&neighbor_entry, &sai_attr);
    return status;
  }

  void sai_thrift_get_neighbor_entry(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;
    sai_neighbor_entry_t neighbor_entry;
    memset(&neighbor_entry, 0, sizeof(neighbor_entry));
    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    sai_attribute_t sai_attr;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    sai_attr.id = thrift_attr.id;
    neighbor_api->get_neighbor_entry_attribute(&neighbor_entry, 1, &sai_attr);

    ret_thrift_attr.id = thrift_attr.id;
    if (thrift_attr.id == SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS) {
    }
    std::string mac_str = sai_mac_to_thrift_string(sai_attr.value.mac);
    ret_thrift_attr.value.mac = mac_str;
  }

#define SWITCH_SAI_ATTR_NUM 20
  void sai_thrift_get_switch_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_attribute_t max_port_attribute;
    sai_attribute_t table_size_attribute[SWITCH_SAI_ATTR_NUM];
    sai_attribute_t port_list_object_attribute;
    sai_thrift_attribute_t thrift_port_list_attribute;
    sai_thrift_attribute_t thrift_table_size_attribute[SWITCH_SAI_ATTR_NUM];
    sai_object_list_t *port_list_object;
    int max_ports = 0;
    int switch_attr_list[SWITCH_SAI_ATTR_NUM] = {
        SAI_SWITCH_ATTR_L3_NEIGHBOR_TABLE_SIZE,
        SAI_SWITCH_ATTR_CPU_PORT,
        SAI_SWITCH_ATTR_LAG_MEMBERS,
        SAI_SWITCH_ATTR_ECMP_MEMBERS,
        SAI_SWITCH_ATTR_MAX_VIRTUAL_ROUTERS,
        SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID,
        SAI_SWITCH_ATTR_DEFAULT_VLAN_ID,
        SAI_SWITCH_ATTR_FDB_TABLE_SIZE,
        SAI_SWITCH_ATTR_NUMBER_OF_LAGS,
        SAI_SWITCH_ATTR_NUMBER_OF_ECMP_GROUPS,
        SAI_SWITCH_ATTR_L3_NEIGHBOR_TABLE_SIZE,
        SAI_SWITCH_ATTR_L3_ROUTE_TABLE_SIZE,
        SAI_SWITCH_ATTR_NUMBER_OF_QUEUES,
        SAI_SWITCH_ATTR_NUMBER_OF_CPU_QUEUES,
        SAI_SWITCH_ATTR_INGRESS_BUFFER_POOL_NUM,
        SAI_SWITCH_ATTR_EGRESS_BUFFER_POOL_NUM,
        SAI_SWITCH_ATTR_TOTAL_BUFFER_SIZE,
        SAI_SWITCH_ATTR_PORT_NUMBER,
        SAI_SWITCH_ATTR_COUNTER_REFRESH_INTERVAL,
        SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_TRAFFIC_CLASSES,
    };

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
    switch_api->get_switch_attribute(0, 1, &max_port_attribute);
    max_ports = max_port_attribute.value.u32;
    port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
    port_list_object_attribute.value.objlist.list =
        (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * max_ports);
    switch_api->get_switch_attribute(0, 1, &port_list_object_attribute);

    thrift_attr_list.attr_count = 1;
    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;
    thrift_port_list_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
    thrift_port_list_attribute.value.objlist.count = max_ports;
    std::vector<sai_thrift_object_id_t> &port_list =
        thrift_port_list_attribute.value.objlist.object_id_list;
    port_list_object = &port_list_object_attribute.value.objlist;
    for (int index = 0; index < max_ports; index++) {
      port_list.push_back(
          (sai_thrift_object_id_t)port_list_object->list[index]);
    }

    attr_list.push_back(thrift_port_list_attribute);
    free(port_list_object_attribute.value.objlist.list);

    for (int i = 0; i < SWITCH_SAI_ATTR_NUM; i++) {
      table_size_attribute[i].id = switch_attr_list[i];
    }
    switch_api->get_switch_attribute(
        0, SWITCH_SAI_ATTR_NUM, table_size_attribute);

    for (int i = 0; i < SWITCH_SAI_ATTR_NUM; i++) {
      thrift_table_size_attribute[i].id = switch_attr_list[i];
      thrift_table_size_attribute[i].value.u32 =
          table_size_attribute[i].value.u32;
      attr_list.push_back(thrift_table_size_attribute[i]);
    }
  }

  sai_thrift_status_t sai_thrift_set_switch_attribute(
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_attribute_t attr;
    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    attr.id = thrift_attr.id;
    switch (thrift_attr.id) {
      case SAI_SWITCH_ATTR_SRC_MAC_ADDRESS:
        sai_thrift_string_to_mac(thrift_attr.value.mac, attr.value.mac);
        break;

      case SAI_SWITCH_ATTR_COUNTER_REFRESH_INTERVAL:
        attr.value.u32 = thrift_attr.value.u32;
        break;
    }
    status = switch_api->set_switch_attribute(0, &attr);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;
    sai_object_id_t hif_id;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_hostif_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = hostif_api->create_hostif(&hif_id, 0, attr_count, attr_list);
    free(attr_list);
    return hif_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif(
      const sai_thrift_object_id_t hif_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = hostif_api->remove_hostif((sai_object_id_t)hif_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_table_entry(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;
    sai_object_id_t hif_table_entry_id;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_hostif_talbe_entry_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = hostif_api->create_hostif_table_entry(
        &hif_table_entry_id, 0, attr_count, attr_list);
    free(attr_list);
    return hif_table_entry_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_table_entry(
      const sai_thrift_object_id_t hif_table_entry_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = hostif_api->remove_hostif_table_entry(
        (sai_object_id_t)hif_table_entry_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;
    sai_object_id_t hif_trap_group_id;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_hostif_hostif_trap_group_attributes(thrift_attr_list,
                                                         attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = hostif_api->create_hostif_trap_group(
        &hif_trap_group_id, 0, attr_count, attr_list);
    free(attr_list);
    return hif_trap_group_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_trap_group(
      const sai_thrift_object_id_t hif_trap_group_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = hostif_api->remove_hostif_trap_group(
        (sai_object_id_t)hif_trap_group_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api = NULL;
    sai_object_id_t hif_trap_id = 0;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_hostif_trap_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status =
        hostif_api->create_hostif_trap(&hif_trap_id, 0, attr_count, attr_list);
    free(attr_list);
    return hif_trap_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_trap(
      const sai_thrift_object_id_t hif_trap_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api = NULL;
    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = hostif_api->remove_hostif_trap(hif_trap_id);
    return status;
  }

  void sai_thrift_parse_acl_table_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_TABLE_ATTR_ACL_STAGE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        case SAI_ACL_TABLE_ATTR_FIELD_SRC_IPV6:
        case SAI_ACL_TABLE_ATTR_FIELD_DST_IPV6:
        case SAI_ACL_TABLE_ATTR_FIELD_SRC_MAC:
        case SAI_ACL_TABLE_ATTR_FIELD_DST_MAC:
        case SAI_ACL_TABLE_ATTR_FIELD_SRC_IP:
        case SAI_ACL_TABLE_ATTR_FIELD_DST_IP:
        case SAI_ACL_TABLE_ATTR_FIELD_IN_PORTS:
        case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORTS:
        case SAI_ACL_TABLE_ATTR_FIELD_IN_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_ID:
        case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_PRI:
        case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_CFI:
        case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_ID:
        case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_PRI:
        case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_CFI:
        case SAI_ACL_TABLE_ATTR_FIELD_L4_SRC_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_L4_DST_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_ETHER_TYPE:
        case SAI_ACL_TABLE_ATTR_FIELD_IP_PROTOCOL:
        case SAI_ACL_TABLE_ATTR_FIELD_DSCP:
        case SAI_ACL_TABLE_ATTR_FIELD_ECN:
        case SAI_ACL_TABLE_ATTR_FIELD_TTL:
        case SAI_ACL_TABLE_ATTR_FIELD_TOS:
        case SAI_ACL_TABLE_ATTR_FIELD_IP_FLAGS:
        case SAI_ACL_TABLE_ATTR_FIELD_TCP_FLAGS:
        case SAI_ACL_TABLE_ATTR_FIELD_ACL_IP_TYPE:
        case SAI_ACL_TABLE_ATTR_FIELD_ACL_IP_FRAG:
        case SAI_ACL_TABLE_ATTR_FIELD_IPV6_FLOW_LABEL:
        case SAI_ACL_TABLE_ATTR_FIELD_TC:
          break;

        case SAI_ACL_TABLE_GROUP_ATTR_ACL_BIND_POINT_TYPE_LIST: {
          int count = attribute.value.s32list.s32list.size();
          int32_t *bp_list = NULL;
          std::vector<int32_t>::const_iterator it =
              attribute.value.s32list.s32list.begin();
          bp_list = (int32_t *)malloc(sizeof(int32_t) * count);
          for (int j = 0; j < count; j++, it++) *(bp_list + j) = (int32_t)*it;
          attr_list[i].value.s32list.list = bp_list;
          attr_list[i].value.s32list.count = count;
        } break;

        default:
          break;
      }
    }
  }

  void sai_thrift_parse_acl_entry_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_ENTRY_ATTR_TABLE_ID:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_PRIORITY:
          attr_list[i].value.aclfield.data.u32 =
              attribute.value.aclfield.data.u32;
          break;
        case SAI_ACL_ENTRY_ATTR_ADMIN_STATE:
          attr_list[i].value.aclfield.data.u8 =
              attribute.value.aclfield.data.u8;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPV6:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_IPV6:
          sai_thrift_string_to_v6_ip(attribute.value.aclfield.data.ip6,
                                     attr_list[i].value.aclfield.data.ip6);
          sai_thrift_string_to_v6_ip(attribute.value.aclfield.mask.ip6,
                                     attr_list[i].value.aclfield.mask.ip6);
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC:
          sai_thrift_string_to_mac(attribute.value.aclfield.data.mac,
                                   attr_list[i].value.aclfield.data.mac);
          sai_thrift_string_to_mac(attribute.value.aclfield.mask.mac,
                                   attr_list[i].value.aclfield.mask.mac);
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_IP:
          sai_thrift_string_to_v4_ip(attribute.value.aclfield.data.ip4,
                                     &attr_list[i].value.aclfield.data.ip4);
          sai_thrift_string_to_v4_ip(attribute.value.aclfield.mask.ip4,
                                     &attr_list[i].value.aclfield.mask.ip4);
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        //            case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS:

        case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        /*
        case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORTS:
        */
        case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI:
        case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI:
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID:
        case SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT:
        case SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT:
        case SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE:
          attr_list[i].value.aclfield.data.u16 =
              attribute.value.aclfield.data.u16;
          attr_list[i].value.aclfield.mask.u16 =
              attribute.value.aclfield.mask.u16;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:
        case SAI_ACL_ENTRY_ATTR_FIELD_DSCP:
        case SAI_ACL_ENTRY_ATTR_FIELD_ECN:
        case SAI_ACL_ENTRY_ATTR_FIELD_TTL:
        case SAI_ACL_ENTRY_ATTR_FIELD_TOS:
        //            case SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS:
        case SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS:
        //            case SAI_ACL_ENTRY_ATTR_FIELD_IP_TYPE:
        //            case SAI_ACL_ENTRY_ATTR_FIELD_IP_FRAG:
        case SAI_ACL_ENTRY_ATTR_FIELD_TC:
          attr_list[i].value.aclfield.data.u8 =
              attribute.value.aclfield.data.u8;
          attr_list[i].value.aclfield.mask.u8 =
              attribute.value.aclfield.mask.u8;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_FLOW_LABEL:
          attr_list[i].value.aclfield.data.u16 =
              attribute.value.aclfield.data.u16;
          attr_list[i].value.aclfield.mask.u16 =
              attribute.value.aclfield.mask.u16;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_COUNTER:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION:
          attr_list[i].value.aclfield.data.s32 =
              attribute.value.aclfield.data.s32;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_ACL_RANGE_TYPE: {
          int count =
              attribute.value.aclfield.data.objlist.object_id_list.size();
          sai_object_id_t *oid_list = NULL;
          std::vector<sai_thrift_object_id_t>::const_iterator it =
              attribute.value.aclfield.data.objlist.object_id_list.begin();
          oid_list = (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * count);
          for (int j = 0; j < count; j++, it++)
            *(oid_list + j) = (sai_object_id_t)*it;
          attr_list[i].value.aclfield.data.objlist.list = oid_list;
          attr_list[i].value.aclfield.data.objlist.count = count;
        } break;
        default:
          break;
      }
    }
  }

  void sai_thrift_convert_to_acl_range_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_RANGE_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_ACL_RANGE_ATTR_LIMIT:
          attr_list[i].value.u32range.min = attribute.value.u32range.min;
          attr_list[i].value.u32range.max = attribute.value.u32range.max;
          break;
      }
    }
  }

  void sai_thrift_convert_to_acl_counter_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_COUNTER_ATTR_TABLE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_PACKETS:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_ACL_COUNTER_ATTR_BYTES:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
      }
    }
  }
  void sai_thrift_convert_to_acl_thrift_counter_attributes(
      sai_attribute_t *attr_list,
      uint32_t attr_count,
      std::vector<sai_thrift_attribute_value_t> &thrift_attr_value_list) {
    sai_attribute_t attribute;
    sai_thrift_attribute_value_t thrift_attribute_value;
    for (uint32_t i = 0; i < attr_count; i++) {
      attribute = attr_list[i];
      switch (attribute.id) {
        case SAI_ACL_COUNTER_ATTR_TABLE_ID:
          thrift_attribute_value.oid = attribute.value.oid;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
          thrift_attribute_value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
          thrift_attribute_value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_PACKETS:
          thrift_attribute_value.u64 = attribute.value.u64;
          break;
        case SAI_ACL_COUNTER_ATTR_BYTES:
          thrift_attribute_value.u64 = attribute.value.u64;
          break;
      }
      thrift_attr_value_list.push_back(thrift_attribute_value);
    }
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_table = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_acl_table_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = acl_api->create_acl_table(&acl_table, 0, attr_count, attr_list);
    free(attr_list);
    return acl_table;
  }

  sai_thrift_status_t sai_thrift_remove_acl_table(
      const sai_thrift_object_id_t acl_table_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_table(acl_table_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_entry(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_entry = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_acl_entry_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = acl_api->create_acl_entry(&acl_entry, 0, attr_count, attr_list);
    free(attr_list);
    return acl_entry;
  }

  sai_thrift_status_t sai_thrift_set_acl_entry_attribute(
      const sai_thrift_object_id_t acl_entry_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_attribute_t attr;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);

    sai_thrift_parse_acl_entry_attributes(thrift_attr_list, &attr);
    status = acl_api->set_acl_entry_attribute(acl_entry_id, &attr);
    return status;
  }

  void sai_thrift_convert_to_acl_entry_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_list) {
    sai_attribute_t sai_attr;
    sai_thrift_attribute_t thrift_acl_entry_attribute;
    char v4_str[INET_ADDRSTRLEN];
    char v6_str[INET6_ADDRSTRLEN];
    std::string dst_v4_str;
    std::string dst_v6_str;
    std::string mac_str;

    for (int i = 0; i < attr_count; i++) {
      sai_attr = attr_list[i];
      thrift_acl_entry_attribute.id = sai_attr.id;
      switch (sai_attr.id) {
        case SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION:
          thrift_acl_entry_attribute.value.aclfield.data.s32 =
              sai_attr.value.aclfield.data.s32;
          break;

        case SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER:
        case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS:
        case SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT:
        case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS:
          thrift_acl_entry_attribute.value.aclfield.data.oid =
              sai_attr.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_IP:
          dst_v4_str = sai_ipv4_to_thrift_string(
              v4_str, &sai_attr.value.aclfield.data.ip4);
          thrift_acl_entry_attribute.value.aclfield.data.ip4 = dst_v4_str;
          break;

        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPV6:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_IPV6:
          dst_v6_str = sai_ipv6_to_thrift_string(
              v6_str, sai_attr.value.aclfield.data.ip6);
          thrift_acl_entry_attribute.value.aclfield.data.ip6 = dst_v6_str;
          break;

        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC:
          mac_str = sai_mac_to_thrift_string(sai_attr.value.aclfield.data.mac);
          thrift_acl_entry_attribute.value.aclfield.data.mac = mac_str;
          break;

        case SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:
        case SAI_ACL_ENTRY_ATTR_FIELD_TTL:
          thrift_acl_entry_attribute.value.aclfield.data.u16 =
              sai_attr.value.aclfield.data.u16;
          break;

        default:
          break;
      }
      thrift_attr_list.attr_list.push_back(thrift_acl_entry_attribute);
    }
  }

  void sai_thrift_get_acl_entry_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t acl_entry_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    uint32_t attr_count = 1;
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t));

    memset(attr_list, 0, sizeof(sai_attribute_t));
    for (uint32_t i = 0; i < attr_count; i++) {
      attr_list[i].id = thrift_attr.id;
    }
    status =
        acl_api->get_acl_entry_attribute(acl_entry_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }
    sai_thrift_convert_to_acl_entry_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
    free(attr_list);
  }

  sai_thrift_status_t sai_thrift_remove_acl_entry(
      const sai_thrift_object_id_t acl_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_entry(acl_entry);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_counter(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_counter_id = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_convert_to_acl_counter_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status =
        acl_api->create_acl_counter(&acl_counter_id, 0, attr_count, attr_list);
    free(attr_list);
    return acl_counter_id;
  }

  sai_thrift_status_t sai_thrift_remove_acl_counter(
      const sai_thrift_object_id_t acl_counter_id) {
    sai_object_id_t acl_entry = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_counter(acl_counter_id);
    return status;
  }

  void sai_thrift_get_acl_counter_attribute(
      std::vector<sai_thrift_attribute_value_t> &thrift_attr_values,
      const sai_thrift_object_id_t acl_counter_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_object_id_t acl_entry = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    uint32_t attr_count = thrift_attr_ids.size();
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_ids.size());
    memset(attr_list,
           0x0,
           sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = acl_api->get_acl_counter_attribute(
        acl_counter_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    sai_thrift_convert_to_acl_thrift_counter_attributes(
        attr_list, attr_count, thrift_attr_values);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_range(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_range_id = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_convert_to_acl_range_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = acl_api->create_acl_range(&acl_range_id, 0, attr_count, attr_list);
    free(attr_list);
    return acl_range_id;
  }

  sai_thrift_status_t sai_thrift_delete_acl_range(
      const sai_thrift_object_id_t acl_range_id) {
    sai_object_id_t acl_entry = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_range(acl_range_id);
    return status;
  }

  void sai_thrift_parse_mirror_session_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_MIRROR_SESSION_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_MIRROR_SESSION_ATTR_MONITOR_PORT:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_MIRROR_SESSION_ATTR_TC:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_TPID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_PRI:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_ERSPAN_ENCAPSULATION_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_MIRROR_SESSION_ATTR_IPHDR_VERSION:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_TOS:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_TTL:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_SRC_IP_ADDRESS:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_MIRROR_SESSION_ATTR_DST_IP_ADDRESS:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_MIRROR_SESSION_ATTR_SRC_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
        case SAI_MIRROR_SESSION_ATTR_DST_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
        case SAI_MIRROR_SESSION_ATTR_GRE_PROTOCOL_TYPE:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_convert_to_mirror_thrift_attributes(
      sai_attribute_t *attr, sai_thrift_attribute_t *thrift_attr) {
    std::string mac_str;
    switch (attr->id) {
      case SAI_MIRROR_SESSION_ATTR_TYPE:
        thrift_attr->value.s32 = attr->value.s32;
        break;
      case SAI_MIRROR_SESSION_ATTR_MONITOR_PORT:
        thrift_attr->value.oid = attr->value.oid;
        break;
      case SAI_MIRROR_SESSION_ATTR_VLAN_ID:
        thrift_attr->value.u16 = attr->value.u16;
        break;
      case SAI_MIRROR_SESSION_ATTR_VLAN_PRI:
        thrift_attr->value.u8 = attr->value.u8;
        break;
      case SAI_MIRROR_SESSION_ATTR_TOS:
        thrift_attr->value.u8 = attr->value.u8;
        break;
      case SAI_MIRROR_SESSION_ATTR_TTL:
        thrift_attr->value.u8 = attr->value.u8;
        break;
      case SAI_MIRROR_SESSION_ATTR_SRC_IP_ADDRESS:
        break;
      case SAI_MIRROR_SESSION_ATTR_DST_IP_ADDRESS:
        break;
      case SAI_MIRROR_SESSION_ATTR_SRC_MAC_ADDRESS:
        mac_str = sai_mac_to_thrift_string(attr->value.mac);
        thrift_attr->value.mac = mac_str;
        break;
      case SAI_MIRROR_SESSION_ATTR_DST_MAC_ADDRESS:
        mac_str = sai_mac_to_thrift_string(attr->value.mac);
        thrift_attr->value.mac = mac_str;
        break;
      case SAI_MIRROR_SESSION_ATTR_GRE_PROTOCOL_TYPE:
        thrift_attr->value.u16 = attr->value.u16;
        break;
      default:
        break;
    }
  }

  sai_thrift_object_id_t sai_thrift_create_mirror_session(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;
    sai_object_id_t session_id = 0;
    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_mirror_session_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    mirror_api->create_mirror_session(&session_id, 0, attr_count, attr_list);
    free(attr_list);
    return session_id;
  }

  sai_thrift_status_t sai_thrift_remove_mirror_session(
      const sai_thrift_object_id_t session_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;
    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = mirror_api->remove_mirror_session((sai_object_id_t)session_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_mirror_session(
      const sai_thrift_object_id_t session_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;
    sai_attribute_t sai_attr;
    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_thrift_parse_mirror_session_attributes(thrift_attr_list, &sai_attr);
    status = mirror_api->set_mirror_session_attribute(session_id, &sai_attr);
    return status;
  }

  void sai_thrift_get_mirror_session(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t session_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;
    sai_attribute_t sai_attr;
    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    sai_attr.id = thrift_attr.id;
    mirror_api->get_mirror_session_attribute(session_id, 1, &sai_attr);
    sai_thrift_convert_to_mirror_thrift_attributes(&sai_attr, &ret_thrift_attr);
  }

  void sai_thrift_parse_policer_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_POLICER_ATTR_METER_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_COLOR_SOURCE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_CBS:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_CIR:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_PBS:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_PIR:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_GREEN_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_YELLOW_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_RED_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
      }
    }
  }

  void sai_thrift_convert_to_policer_thrift_attribute(
      sai_attribute_t *attr, sai_thrift_attribute_t *thrift_attr) {
    switch (attr->id) {
      case SAI_POLICER_ATTR_CBS:
      case SAI_POLICER_ATTR_CIR:
      case SAI_POLICER_ATTR_PBS:
      case SAI_POLICER_ATTR_PIR:
        thrift_attr->value.oid = attr->value.oid;
        break;

      case SAI_POLICER_ATTR_METER_TYPE:
      case SAI_POLICER_ATTR_MODE:
      case SAI_POLICER_ATTR_COLOR_SOURCE:
      case SAI_POLICER_ATTR_GREEN_PACKET_ACTION:
      case SAI_POLICER_ATTR_YELLOW_PACKET_ACTION:
      case SAI_POLICER_ATTR_RED_PACKET_ACTION:
        thrift_attr->value.u32 = attr->value.u32;
        break;

      default:
        break;
    }
  }

  sai_thrift_object_id_t sai_thrift_create_policer(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;
    sai_object_id_t policer_id = 0;
    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_policer_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    policer_api->create_policer(&policer_id, 0, attr_count, attr_list);
    free(attr_list);
    return policer_id;
  }

  sai_thrift_status_t sai_thrift_remove_policer(
      const sai_thrift_object_id_t policer_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;
    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = policer_api->remove_policer((sai_object_id_t)policer_id);
    return status;
  }
  void sai_thrift_get_policer_attribute(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t policer_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_policer_api_t *policer_api;
    sai_api_query(SAI_API_POLICER, (void **)&policer_api);

    sai_attribute_t attr;
    memset(&attr, 0, sizeof(sai_attribute_t));
    attr.id = thrift_attr.id;
    policer_api->get_policer_attribute(policer_id, 1, &attr);
    sai_thrift_convert_to_policer_thrift_attribute(&attr, &ret_thrift_attr);
  }

  void sai_thrift_get_policer_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t policer_id,
      const std::vector<sai_thrift_policer_stat_t> &thrift_counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;
    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    sai_policer_stat_t *counter_ids = (sai_policer_stat_t *)malloc(
        sizeof(sai_policer_stat_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_policer_stat_t)*it;
    }

    int32_t number_of_counters = thrift_counter_ids.size();
    status = policer_api->get_policer_stats(
        (sai_object_id_t)policer_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  void sai_thrift_convert_to_pool_thrift_attribute(
      sai_attribute_t *attr, sai_thrift_attribute_t *thrift_attr) {
    switch (attr->id) {
      case SAI_BUFFER_POOL_ATTR_TYPE:
      case SAI_BUFFER_POOL_ATTR_SIZE:
      case SAI_BUFFER_POOL_ATTR_THRESHOLD_MODE:
        thrift_attr->value.u32 = attr->value.u32;
        break;

      default:
        break;
    }
  }

  void sai_thrift_parse_buffer_pool_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_BUFFER_POOL_ATTR_SHARED_SIZE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_POOL_ATTR_TYPE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_BUFFER_POOL_ATTR_SIZE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_POOL_ATTR_THRESHOLD_MODE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_pool(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    sai_object_id_t pool_id = 0;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    memset(attr_list, 0, sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_buffer_pool_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    buffer_api->create_buffer_pool(&pool_id, 0, attr_count, attr_list);
    free(attr_list);
    return pool_id;
  }

  sai_thrift_status_t sai_thrift_remove_buffer_pool(
      const sai_thrift_object_id_t pool_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = buffer_api->remove_buffer_pool(pool_id);
    return status;
  }

  void sai_thrift_get_buffer_pool_attribute(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t pool_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);

    sai_attribute_t attr;
    memset(&attr, 0, sizeof(sai_attribute_t));
    attr.id = thrift_attr.id;
    buffer_api->get_buffer_pool_attribute(pool_id, 1, &attr);
    sai_thrift_convert_to_pool_thrift_attribute(&attr, &ret_thrift_attr);
  }

  void sai_thrift_parse_buffer_profile_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_BUFFER_PROFILE_ATTR_POOL_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_BUFFER_PROFILE_ATTR_BUFFER_SIZE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_PROFILE_ATTR_SHARED_DYNAMIC_TH:
        case SAI_BUFFER_PROFILE_ATTR_THRESHOLD_MODE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_BUFFER_PROFILE_ATTR_SHARED_STATIC_TH:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_PROFILE_ATTR_XOFF_TH:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_PROFILE_ATTR_XON_TH:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    sai_object_id_t buffer_profile_id = 0;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_buffer_profile_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    buffer_api->create_buffer_profile(
        &buffer_profile_id, 0, attr_count, attr_list);
    free(attr_list);
    return buffer_profile_id;
  }

  sai_thrift_status_t sai_thrift_remove_buffer_profile(
      const sai_thrift_object_id_t buffer_profile_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = buffer_api->remove_buffer_profile(buffer_profile_id);
    return status;
  }

 void sai_thrift_get_buffer_profile_attribute(
     sai_thrift_attribute_t &ret_thrift_attr,
     const sai_thrift_object_id_t profile_id,
     const sai_thrift_attribute_t &thrift_attr) {
   sai_status_t status = SAI_STATUS_SUCCESS;
   sai_buffer_api_t *buffer_api;
   status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);

   sai_attribute_t attr;
   memset(&attr, 0, sizeof(sai_attribute_t));
   attr.id = thrift_attr.id;
   buffer_api->get_buffer_profile_attribute(profile_id, 1, &attr);
   sai_thrift_convert_to_profile_thrift_attribute(&attr, &ret_thrift_attr);
 }

 sai_thrift_status_t sai_thrift_set_buffer_profile_attribute(
     const sai_thrift_object_id_t profile_id,
     const sai_thrift_attribute_t &thrift_attr) {
   sai_status_t status = SAI_STATUS_SUCCESS;
   sai_buffer_api_t *buffer_api;
   status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
   if (status != SAI_STATUS_SUCCESS) {
     return status;
   }

   sai_attribute_t attr;
   memset(&attr, 0x0, sizeof(sai_attribute_t));
   attr.id = thrift_attr.id;
   attr.value.oid = thrift_attr.value.u32;
   status = buffer_api->set_buffer_profile_attribute(profile_id, &attr);
   return status;
 }

  sai_thrift_status_t sai_thrift_set_ingress_priority_group_attribute(
      const sai_thrift_object_id_t ingress_pg_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr;
    memset(&attr, 0x0, sizeof(sai_attribute_t));
    attr.id = thrift_attr.id;
    attr.value.oid = thrift_attr.value.oid;

    status =
        buffer_api->set_ingress_priority_group_attribute(ingress_pg_id, &attr);
    return status;
  }

  void sai_thrift_parse_scheduler_profile_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_SCHEDULER_ATTR_SCHEDULING_TYPE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_ATTR_METER_TYPE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        default:
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    sai_object_id_t scheduler_id = 0;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_scheduler_profile_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    scheduler_api->create_scheduler(&scheduler_id, 0, attr_count, attr_list);
    free(attr_list);
    return scheduler_id;
  }

  sai_thrift_status_t sai_thrift_remove_scheduler_profile(
      const sai_thrift_object_id_t scheduler_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = scheduler_api->remove_scheduler(scheduler_id);
    return status;
  }
  sai_thrift_status_t sai_thrift_set_scheduler_profile(
      const sai_thrift_object_id_t scheduler_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_attribute_t attr;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    attr.id = thrift_attr.id;
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_thrift_parse_scheduler_profile_attributes(thrift_attr_list, &attr);
    return scheduler_api->set_scheduler_attribute(scheduler_id, &attr);
  }

  void sai_thrift_convert_to_scheduler_thrift_attribute(
      sai_attribute_t &sai_attr, sai_thrift_attribute_t &thrift_attr) {
    switch (sai_attr.id) {
      case SAI_SCHEDULER_ATTR_SCHEDULING_TYPE:
      case SAI_SCHEDULER_ATTR_METER_TYPE:
        thrift_attr.value.u32 = sai_attr.value.u32;
        break;

      case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
        thrift_attr.value.u8 = sai_attr.value.u8;
        break;
      case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
      case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
      case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE:
      case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
        thrift_attr.value.u64 = sai_attr.value.u64;
      default:
        break;
    }
  }

  void sai_thrift_get_scheduler_profile(
      sai_thrift_attribute_t &thrift_attr,
      const sai_thrift_object_id_t scheduler_id,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    sai_attribute_t sai_attr;
    sai_attr.id = attr.id;
    status = scheduler_api->get_scheduler_attribute(scheduler_id, 1, &sai_attr);

    thrift_attr.id = sai_attr.id;
    sai_thrift_convert_to_scheduler_thrift_attribute(sai_attr, thrift_attr);
  }

  void sai_thrift_parse_scheduler_group_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST:
          break;
        case SAI_SCHEDULER_GROUP_ATTR_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_SCHEDULER_GROUP_ATTR_LEVEL:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    sai_object_id_t scheduler_group_id = 0;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_scheduler_group_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    scheduler_group_api->create_scheduler_group(
        &scheduler_group_id, 0, attr_count, attr_list);
    free(attr_list);
    return scheduler_group_id;
  }

  void sai_thrift_get_scheduler_group_attribute(
      sai_thrift_attribute_t &thrift_attr,
      sai_thrift_object_id_t group_id,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    sai_attribute_t sai_attr;
    if (attr.id == SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST) {
      sai_attr.id = SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT;
      status = scheduler_group_api->get_scheduler_group_attribute(
          group_id, 1, &sai_attr);
      int num_groups = sai_attr.value.u32;

      sai_attr.value.objlist.list =
          (sai_object_id_t *)malloc(num_groups * sizeof(sai_object_id_t));
      sai_attr.id = SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST;
      sai_attr.value.objlist.count = num_groups;
      status = scheduler_group_api->get_scheduler_group_attribute(
          group_id, 1, &sai_attr);

      thrift_attr.id = SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST;
      thrift_attr.value.objlist.count = num_groups;
      std::vector<sai_thrift_object_id_t> &child_list =
          thrift_attr.value.objlist.object_id_list;

      for (int index = 0; index < num_groups; index++) {
        child_list.push_back(
            (sai_thrift_object_id_t)sai_attr.value.objlist.list[index]);
      }
    }
    free(sai_attr.value.objlist.list);
  }

  sai_thrift_status_t sai_thrift_remove_scheduler_group(
      const sai_thrift_object_id_t scheduler_group_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = scheduler_group_api->remove_scheduler_group(scheduler_group_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_scheduler_group(
      const sai_thrift_object_id_t scheduler_group_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_attribute_t attr;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    attr.id = thrift_attr.id;
    if (attr.id == SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID) {
      attr.value.oid = thrift_attr.value.oid;
    }
    return scheduler_group_api->set_scheduler_group_attribute(
        scheduler_group_id, &attr);
  }

  void sai_thrift_parse_qos_map_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_qos_map_t **qos_map_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    sai_qos_map_type_t qos_map_type = (sai_qos_map_type_t)0;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_QOS_MAP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          qos_map_type = (sai_qos_map_type_t)attribute.value.s32;
          break;
        case SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST:
          attr_list[i].value.qosmap.list = (sai_qos_map_t *)malloc(
              attribute.value.qosmap.key.size() * sizeof(sai_qos_map_t));
          attr_list[i].value.qosmap.count = attribute.value.qosmap.key.size();
          *qos_map_list = attr_list[i].value.qosmap.list;
          memset(attr_list[i].value.qosmap.list,
                 0x0,
                 attribute.value.qosmap.key.size() * sizeof(sai_qos_map_t));
          std::vector<sai_thrift_qos_map_params_t>::const_iterator it1 =
              attribute.value.qosmap.key.begin();
          std::vector<sai_thrift_qos_map_params_t>::const_iterator it2 =
              attribute.value.qosmap.data.begin();
          for (uint32_t j = 0; j < attribute.value.qosmap.key.size();
               j++, it1++, it2++) {
            sai_qos_map_params_t *key = &attr_list[i].value.qosmap.list[j].key;
            sai_qos_map_params_t *data =
                &attr_list[i].value.qosmap.list[j].value;
            const sai_thrift_qos_map_params_t thrift_key =
                (sai_thrift_qos_map_params_t)*it1;
            const sai_thrift_qos_map_params_t thrift_data =
                (sai_thrift_qos_map_params_t)*it2;

            switch (qos_map_type) {
              case SAI_QOS_MAP_TYPE_DOT1P_TO_TC:
                key->dot1p = thrift_key.dot1p;
                data->tc = thrift_data.tc;
                break;
              case SAI_QOS_MAP_TYPE_DOT1P_TO_COLOR:
                key->dot1p = thrift_key.dot1p;
                data->color = (sai_packet_color_t)thrift_data.color;
                break;
              case SAI_QOS_MAP_TYPE_DSCP_TO_TC:
                key->dscp = thrift_key.dscp;
                data->tc = thrift_data.tc;
                break;
              case SAI_QOS_MAP_TYPE_DSCP_TO_COLOR:
                key->dscp = thrift_key.dscp;
                data->color = (sai_packet_color_t)thrift_data.color;
                break;
              case SAI_QOS_MAP_TYPE_TC_TO_QUEUE:
                key->tc = thrift_key.tc;
                data->queue_index = thrift_data.queue_index;
                break;
              case SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP:
                key->tc = thrift_key.tc;
                key->color = (sai_packet_color_t)thrift_key.color;
                data->dscp = thrift_data.dscp;
                break;
              case SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P:
                key->tc = thrift_key.tc;
                key->color = (sai_packet_color_t)thrift_key.color;
                data->dot1p = thrift_data.dot1p;
                break;
              case SAI_QOS_MAP_TYPE_PFC_PRIORITY_TO_PRIORITY_GROUP:
                key->prio = thrift_key.prio;
                data->pg = thrift_data.pg;
                break;
              case SAI_QOS_MAP_TYPE_PFC_PRIORITY_TO_QUEUE:
                key->prio = thrift_key.prio;
                data->queue_index = thrift_data.queue_index;
                break;
              default:
                break;
            }
          }
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_qos_map(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_api;
    sai_object_id_t qos_map_id = 0;
    sai_qos_map_t *qos_map_list = NULL;
    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_qos_map_attributes(
        thrift_attr_list, attr_list, &qos_map_list);
    uint32_t attr_count = thrift_attr_list.size();
    qos_api->create_qos_map(&qos_map_id, 0, attr_count, attr_list);
    if (qos_map_list) {
      free(qos_map_list);
    }
    free(attr_list);
    return qos_map_id;
  }

  sai_thrift_status_t sai_thrift_remove_qos_map(
      const sai_thrift_object_id_t qos_map_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_api;
    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = qos_api->remove_qos_map(qos_map_id);
    return status;
  }

  void sai_thrift_get_qos_map(sai_thrift_attribute_t &ret_thrift_attr,
                              const sai_thrift_object_id_t qos_map_id,
                              const int32_t map_count,
                              const sai_thrift_attribute_t &thrift_attr) {
    sai_qos_map_api_t *qos_api;
    sai_attribute_t sai_attr;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    sai_api_query(SAI_API_QOS_MAP, (void **)&qos_api);
    sai_attr.id = thrift_attr.id;
    if (sai_attr.id == SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
      assert(map_count != 0);
      sai_attr.value.qosmap.list =
          (sai_qos_map_t *)malloc(map_count * sizeof(sai_qos_map_t));
    }
    qos_api->get_qos_map_attribute(qos_map_id, 1, &sai_attr);

    ret_thrift_attr.id = thrift_attr.id;
    sai_thrift_qos_map_params_t thrift_key;
    sai_thrift_qos_map_params_t thrift_data;
    if (sai_attr.id != SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
      ret_thrift_attr.value.u32 = sai_attr.value.u32;
    } else {
      for (int i = 0; i < map_count; i++) {
        memset(&thrift_key, 0, sizeof(sai_thrift_qos_map_params_t));
        memset(&thrift_data, 0, sizeof(sai_thrift_qos_map_params_t));
        thrift_key.dot1p = sai_attr.value.qosmap.list[i].key.dot1p;
        thrift_key.tc = sai_attr.value.qosmap.list[i].key.tc;
        thrift_key.dscp = sai_attr.value.qosmap.list[i].key.dscp;
        thrift_key.color = sai_attr.value.qosmap.list[i].key.color;

        thrift_data.dot1p = sai_attr.value.qosmap.list[i].value.dot1p;
        thrift_data.tc = sai_attr.value.qosmap.list[i].value.tc;
        thrift_data.dscp = sai_attr.value.qosmap.list[i].value.dscp;
        thrift_data.color = sai_attr.value.qosmap.list[i].value.color;
        thrift_data.queue_index =
            sai_attr.value.qosmap.list[i].value.queue_index;

        ret_thrift_attr.value.qosmap.key.push_back(thrift_key);
        ret_thrift_attr.value.qosmap.data.push_back(thrift_data);
      }
    }
    if (sai_attr.id == SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
      free(sai_attr.value.qosmap.list);
    }
  }

  sai_thrift_status_t sai_thrift_set_queue_attribute(
      const sai_thrift_object_id_t queue_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;
    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    sai_attribute_t attr;
    memset(&attr, 0x0, sizeof(sai_attribute_t));
    attr.id = thrift_attr.id;
    attr.value.oid = thrift_attr.value.oid;
    status = queue_api->set_queue_attribute(queue_id, &attr);
    return status;
  }

  void sai_thrift_parse_wred_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr) {
    sai_thrift_attribute_t attribute;

    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    for (int i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr[i].id = attribute.id;

      switch (attribute.id) {
        case SAI_WRED_ATTR_GREEN_ENABLE:
          attr[i].value.booldata = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_GREEN_MIN_THRESHOLD:
          attr[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_GREEN_MAX_THRESHOLD:
          attr[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_GREEN_DROP_PROBABILITY:
          attr[i].value.u32 = attribute.value.u32;
          break;

        case SAI_WRED_ATTR_YELLOW_ENABLE:
          attr[i].value.booldata = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_YELLOW_MIN_THRESHOLD:
          attr[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_YELLOW_MAX_THRESHOLD:
          attr[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_YELLOW_DROP_PROBABILITY:
          attr[i].value.u32 = attribute.value.u32;
          break;

        case SAI_WRED_ATTR_RED_ENABLE:
          attr[i].value.booldata = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_RED_MIN_THRESHOLD:
          attr[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_RED_MAX_THRESHOLD:
          attr[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_RED_DROP_PROBABILITY:
          attr[i].value.u32 = attribute.value.u32;
          break;

        case SAI_WRED_ATTR_ECN_MARK_MODE:
          attr[i].value.u32 = attribute.value.u32;
          break;
      }
    }
  }
  sai_thrift_object_id_t sai_thrift_create_wred_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;
    sai_object_id_t wred_id = 0;
    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    sai_attribute_t *sai_attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    memset(sai_attr_list, 0, (sizeof(sai_attribute_t) * attr_count));
    sai_thrift_parse_wred_attributes(thrift_attr_list, sai_attr_list);
    wred_api->create_wred(&wred_id, 0, attr_count, sai_attr_list);
    return wred_id;
  }
};

static void *switch_sai_thrift_rpc_server_thread(void *arg) {
  int port = *(int *)arg;
  shared_ptr<switch_sai_rpcHandler> handler(new switch_sai_rpcHandler());
  shared_ptr<TProcessor> processor(new switch_sai_rpcProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(
      new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(
      processor, serverTransport, transportFactory, protocolFactory);
  pthread_mutex_lock(&cookie_mutex);
  cookie = (void *)processor.get();
  pthread_cond_signal(&cookie_cv);
  pthread_mutex_unlock(&cookie_mutex); 
  server.serve();
  return 0;
}

static pthread_t switch_sai_thrift_rpc_thread;

extern "C" {
extern void sai_initialize(void);

int start_p4_sai_thrift_rpc_server(char *port) {
  std::cerr << "Starting SAI RPC server on port " << port << std::endl;

  int *port_arg = (int *)malloc(sizeof(int));
  *port_arg = atoi(port);

  sai_initialize();

  int status = pthread_create(&switch_sai_thrift_rpc_thread,
                        NULL,
                        switch_sai_thrift_rpc_server_thread,
                        port_arg);
  if (status) return status;
  pthread_mutex_lock(&cookie_mutex);
  while (!cookie) {
    pthread_cond_wait(&cookie_cv, &cookie_mutex);
  }
  pthread_mutex_unlock(&cookie_mutex);
  pthread_mutex_destroy(&cookie_mutex);
  pthread_cond_destroy(&cookie_cv);
  return status;
}
int stop_p4_sai_thrift_rpc_server(void) {
  int status = pthread_cancel(switch_sai_thrift_rpc_thread);
  if (status == 0) {
     int s = pthread_join(switch_sai_thrift_rpc_thread, NULL);
  }
  return status; 
}
}
